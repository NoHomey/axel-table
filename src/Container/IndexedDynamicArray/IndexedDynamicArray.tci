#include "IndexedDynamicArray.htd"

template<typename Element>
IndexedDynamicArray<Element>::IndexedDynamicArray(size_t size)
: Base{size} { }

template<typename Element>
size_t IndexedDynamicArray<Element>::findArrayIndexOfElementAtIndex(size_t index) const {
    if(Base::isEmpty()) {
        throw EmptyDynamicArray{};
    }
    size_t leftSide = 0;
    size_t rightSide = Base::arraySize - 1;
    size_t center = 0;
    while(leftSide <= rightSide) {
        center = (rightSide + leftSide) / 2;
        if(Base::array[center].index == index) {
            return center;
        }
        if(Base::array[center].index < index) {
            leftSide = center + 1;
        } else {
            if(center > 0) {
                rightSide = center - 1;
            } else {
                break;
            }
        }
    }
    throw IndexNotFound{};
}

template<typename Element>
const Element& IndexedDynamicArray<Element>::operator[](size_t index) const {
    return getElement(index);
}

template<typename Element>
const Element& IndexedDynamicArray<Element>::getElement(size_t index) const {
    const size_t elementIndex = findArrayIndexOfElementAtIndex(index);
    return Base::array[elementIndex].element;
}

template<typename Element>
size_t IndexedDynamicArray<Element>::getFirstElementIndex() const {
    if(!Base::isEmpty()) {
        return Base::array[0].index;
    }
    throw EmptyDynamicArray{};
}

template<typename Element>
size_t IndexedDynamicArray<Element>::getLastElementIndex() const {
    if(!Base::isEmpty()) {
        return Base::array[Base::arraySize - 1].index;
    }
    throw EmptyDynamicArray{};
}

template<typename Element>
void IndexedDynamicArray<Element>::sort() noexcept {
    size_t insertedIndex = Base::arraySize - 1;
    size_t checkedIndex = insertedIndex - 1;
    IndexedElement<Element> temp;
    while((insertedIndex > 0) && (Base::array[checkedIndex].index > Base::array[insertedIndex].index)) {
        temp = Base::array[checkedIndex];
        Base::array[checkedIndex] = Base::array[insertedIndex];
        Base::array[insertedIndex] = temp;
        --checkedIndex;
        --insertedIndex;
    }
}

template<typename Element>
void IndexedDynamicArray<Element>::addNewElement(const Element& element, size_t index) {
    Base::push({index, element});
    sort();
}

template<typename Element>
void IndexedDynamicArray<Element>::setElement(const Element& element, size_t index) {
    try {
        const size_t elementIndex = findArrayIndexOfElementAtIndex(index);
        Base::array[elementIndex].element = element;
    } catch(const Exception& error) {
        addNewElement(element, index);
    }   
}

template<typename Element>
void IndexedDynamicArray<Element>::removeElement(size_t index) {
    if(!Base::isEmpty()) {
        for(size_t arrayIndex = findArrayIndexOfElementAtIndex(index) + 1; arrayIndex < Base::arraySize; ++arrayIndex) {
            Base::array[arrayIndex - 1] = Base::array[arrayIndex];
        }
        --Base::arraySize;
    } else {
        throw EmptyDynamicArray{};
    }
}

template<typename Element>
template<typename ForEachInDynamicArrayFunction>
void IndexedDynamicArray<Element>::forEachElement(ForEachInDynamicArrayFunction function) const noexcept {
    Base::forEach([&function](const IndexedElement<Element>& entry, size_t) {
        function(entry.element, entry.index);
    });
}

template<typename Element>
template<typename ForEachInDynamicArrayFunction>
void IndexedDynamicArray<Element>::forEach(ForEachInDynamicArrayFunction& function) const noexcept {
    forEachElement<ForEachInDynamicArrayFunction&>(function);
}

template<typename Element>
template<typename ForEachInDynamicArrayFunction>
void IndexedDynamicArray<Element>::forEach(const ForEachInDynamicArrayFunction& function) const noexcept {
    forEachElement<const ForEachInDynamicArrayFunction&>(function);
}